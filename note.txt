Изучение GitHub


CHAPTER 1 ------------------------------------------------------------------------------------------------------------------------------------------


>   О системе контроля версий

Система контроля версий (СКВ) — это система, записывающая изменения в файл или набор файлов 
в течение времени и позволяющая вернуться позже к определённой версии. 

    - Локальные системы контроля версий   

        Данный подход очень распространён из-за его простоты, однако он невероятно сильно подвержен появлению ошибок. Можно легко 
        забыть, в какой директории вы находитесь, и случайно изменить не тот файл или скопировать не те файлы, которые вы хотели.

    - Централизованные системы контроля версий (CVS)
        
        Имеют единственный сервер, содержащий все версии файлов, и некоторое 
        количество клиентов, которые получают файлы из этого централизованного хранилища. 
    
        Все разработчики проекта в определённой степени знают, чем занимается каждый из них. Администраторы имеют полный контроль над тем, кто и 
        что может делать, и гораздо проще администрировать ЦСКВ, чем оперировать локальными базами данных на каждом клиенте.

    - Децентрализованные системы контроля версий

       Клиенты не просто скачивают снимок всех файлов (состояние файлов на определённый момент времени): они полностью копируют репозиторий. 
       В этом случае, если один из серверов, через который разработчики обменивались данными, умрёт, любой клиентский репозиторий может быть 
       скопирован на другой сервер для продолжения работы. Каждая копия репозитория является полным бэкапом всех данных. 



>   Краткая история Git

Некоторыми целями, которые преследовала новая система, были:

    -- Скорость
    -- Простая архитектура
    -- Хорошая поддержка нелинейной разработки (тысячи параллельных веток)
    -- Полная децентрализация
    -- Возможность эффективного управления большими проектами, такими как ядро Linux (скорость работы и разумное использование дискового пространства)

С момента своего появления в 2005 году, Git развился в простую в использовании систему, сохранив при этом свои изначальные качества. Он удивительно 
быстр, эффективен в работе с большими проектами и имеет великолепную систему веток для нелинейной разработки.



>   Основы Git

 Подход Git’а к хранению данных больше похож на набор снимков миниатюрной файловой системы. Каждый раз, когда вы делаете коммит, то есть 
 сохраняете состояние своего проекта в Git’е, система запоминает, как выглядит каждый файл в этот момент, и сохраняет ссылку на этот снимок. 
 Для увеличения эффективности, если файлы не были изменены, Git не запоминает эти файлы вновь, а только создаёт ссылку на предыдущую версию 
 идентичного файла, который уже сохранён. Git представляет свои данные как, скажем, поток снимков.

    Целостность Git
        Хеш-сумма - это значит, что невозможно изменить содержимое файла или директории так, чтобы Git не узнал об этом. Данная функциональность 
        встроена в Git на низком уровне и является неотъемлемой частью его философии. Вы не потеряете информацию во время её передачи и не получите 
        повреждённый файл без ведома Git.

    Три состояния

        Git имеет три основных состояния, в которых могут находиться ваши файлы: 
           
            - Зафиксированном (committed)
            - Мзменённом (modified) 
            - Подготовленном (staged)

        “Зафиксированный” значит, что файл уже сохранён в вашей локальной базе. К изменённым относятся файлы, которые поменялись, но ещё не были зафиксированы. 
        Подготовленные файлы — это изменённые файлы, отмеченные для включения в следующий коммит.

        Git-директория — это то место, где Git хранит метаданные и базу объектов вашего проекта. Это самая важная часть Git, и это та часть, которая 
        копируется при клонировании репозитория с другого компьютера.

        Базовый подход в работе с Git выглядит так:
            - Вы изменяете файлы в вашей рабочей директории.
            - Вы добавляете файлы в индекс, добавляя тем самым их снимки в область подготовленных файлов.
            - Когда вы делаете коммит, используются файлы из индекса как есть, и этот снимок сохраняется в вашу Git директорию.



>   Первоначальная настройка Git

    В состав Git’а входит утилита git config, которая позволяет просматривать и настраивать параметры, контролирующие все аспекты 
    работы Git’а, а также его внешний вид. 

    - Имя пользователя

        Первое, что вам следует сделать после установки Git’а, — указать ваше имя и адрес электронной почты. Это важно, потому что каждый коммит в Git’е содержит эту информацию, 
        и она включена в коммиты, передаваемые вами, и не может быть далее изменена:

            $ git config --global user.name "John Doe"
            $ git config --global user.email johndoe@example.com

    - Выбор редактора

        Теперь, когда вы указали своё имя, самое время выбрать текстовый редактор, который будет использоваться, если будет нужно набрать сообщение в Git’е. По умолчанию Git использует стандартный 
        редактор вашей системы, которым обычно является Vim. Если вы хотите использовать другой текстовый редактор, например, Emacs, можно проделать следующее:        

            $ git config --global core.editor emacs 
        
    - Проверка настроек

        Если вы хотите проверить используемую конфигурацию, можете использовать команду git config --list, чтобы показать все настройки, которые Git найдёт:

            $ git config --list
            user.name=John Doe
            user.email=johndoe@example.com
            color.status=auto
            color.branch=auto
            color.interactive=auto
            color.diff=auto
            ...
        
        Также вы можете проверить значение конкретного ключа, выполнив git config <key>:

            $ git config user.name
            John Doe



>   Как получить помощь?

    Если вам нужна помощь при использовании Git, есть три способа открыть страницу руководства по любой команде Git:

        $ git help <глагол>
        $ git <глагол> --help
        $ man git-<глагол>

    Например, так можно открыть руководство по команде config

        $ git help config




CHAPTER 2 ------------------------------------------------------------------------------------------------------------------------------------------


>   Создание Git-репозитория

    Для создания Git-репозитория вы можете использовать два основных подхода. 
        
        - Во-первых, импорт в Git уже существующего проекта или директории. 
        - Во-вторых, клонирование существующего репозитория с другого сервера.

->>   Создание репозитория в существующей директории 

        Если вы собираетесь начать использовать Git для существующего проекта, то вам необходимо перейти в директорию проекта и в командной строке ввести

            $ git init

        Эта команда создаёт в текущей директории новую поддиректорию с именем .git, содержащую все необходимые файлы репозитория — 
        основу Git-репозитория. На этом этапе ваш проект ещё не находится под версионным контролем. 

        Если вы хотите добавить под версионный контроль существующие файлы (в отличие от пустого каталога), вам стоит добавить их в индекс 
        и осуществить первый коммит изменений.

            $ git add *.c
            $ git add LICENSE
            $ git commit -m 'initial project version'

->>    Клонирование существующего репозитория

        Для получения копии существующего Git-репозитория, например, проекта, в который вы хотите внести свой вклад, необходимо использовать команду git clone.
        При выполнении git clone с сервера забирается (pulled) каждая версия каждого файла из истории проекта.

        Клонирование репозитория осуществляется командой git clone [url]. Например, если вы хотите клонировать библиотеку libgit2, 
        вы можете сделать это следующим образом:

            $ git clone https://github.com/libgit2/libgit2

        Для того, чтобы клонировать репозиторий в директорию с именем, отличающимся от “libgit2”, необходимо указать желаемое имя, как параметр командной строки:

            $ git clone https://github.com/libgit2/libgit2 mylibgit

        Эта команда делает всё то же самое, что и предыдущая, только результирующий каталог будет назван mylibgit.




>   Запись изменений в репозиторий



    Запомните, каждый файл в вашем рабочем каталоге может находиться в одном из двух состояний: под версионным контролем (отслеживаемые) и нет (неотслеживаемые). 
    
        - Отслеживаемые файлы — это те файлы, которые были в последнем слепке состояния проекта (snapshot); они могут быть неизменёнными, 
        изменёнными или подготовленными к коммиту (staged). 
        
        - Неотслеживаемые файлы — это всё остальное, любые файлы в вашем рабочем каталоге, которые не входили в ваш последний слепок состояния 
        и не подготовлены к коммиту. 

    
->>    Определение состояния файлов

    Основной инструмент, используемый для определения, какие файлы в каком состоянии находятся — это команда git status. Если вы выполните эту команду 
    сразу после клонирования, вы увидите что-то вроде этого:

        $ git status
        On branch master
        nothing to commit, working directory clean

    Команда сообщает вам на какой ветке вы находитесь и сообщает вам, что она не расходится с веткой на сервере. 
    Пока что это всегда ветка ``master``, ветка по умолчанию; в этой главе это не важно. 

    Предположим, вы добавили в свой проект новый файл, простой файл README. Eсли этого файла раньше не было, и вы выполните git status, 
    вы увидите свой неотслеживаемый файл вот так:

        $ echo 'My Project' > README
        $ git status
        On branch master
        Untracked files:
        (use "git add <file>..." to include in what will be committed)

            README

        nothing added to commit but untracked files present (use "git add" to track)

    Статус ``Untracked files``, по сути, означает, что Git видит файл, отсутствующий в предыдущем снимке состояния (коммите); 
    Git не станет добавлять его в ваши коммиты, пока вы его явно об этом не попросите. 

->>    Отслеживание новых файлов

        Для того чтобы начать отслеживать (добавить под версионный контроль) новый файл, используется команда git add. 
        Чтобы начать отслеживание файла README, вы можете выполнить следующее:

            $ git add README
        
        Если вы снова выполните команду status, то увидите, что файл README теперь отслеживаемый и индексированный:

            $ git status
            On branch master
            Changes to be committed:
            (use "git reset HEAD <file>..." to unstage)

                new file:   README
        
        Вы можете видеть, что файл проиндексирован по тому, что он находится в секции ``Changes to be committed``. 
        Если вы выполните коммит в этот момент, то версия файла, существовавшая на момент выполнения вами команды git add, будет 
        добавлена в историю снимков состояния.
        
->>    Индексация изменённых файлов

        Давайте модифицируем файл, уже находящийся под версионным контролем. Если вы измените отслеживаемый файл ``CONTRIBUTING.md`` 
        и после этого снова выполните команду git status, то результат будет примерно следующим:

            $ git status
            On branch master
            Changes to be committed:
            (use "git reset HEAD <file>..." to unstage)

                new file:   README

            Changes not staged for commit:
            (use "git add <file>..." to update what will be committed)
            (use "git checkout -- <file>..." to discard changes in working directory)

                modified:   CONTRIBUTING.md

        Файл ``CONTRIBUTING.md`` находится в секции ``Changes not staged for commit`` — это означает, что отслеживаемый файл был изменён 
        в рабочем каталоге, но пока не проиндексирован. Чтобы проиндексировать его, необходимо выполнить команду git add. Это многофункциональная 
        команда, она используется для добавления под версионный контроль новых файлов, для индексации изменений, а также для других целей, 
        например для указания файлов с исправленным конфликтом слияния. 

        Выполним git add, чтобы проиндексировать ``CONTRIBUTING.md``, а затем снова выполним git status:

            $ git add CONTRIBUTING.md
            $ git status
            On branch master
            Changes to be committed:
            (use "git reset HEAD <file>..." to unstage)

                new file:   README
                modified:   CONTRIBUTING.md

        Теперь оба файла проиндексированы и войдут в следующий коммит. В этот момент вы, предположим, вспомнили одно небольшое изменение, которое вы 
        хотите сделать в ``CONTRIBUTING.md`` до коммита. Вы открываете файл, вносите и сохраняете необходимые изменения и вроде бы готовы к коммиту. 
        Но давайте-ка ещё раз выполним git status:

            $ vim CONTRIBUTING.md
            $ git status
            On branch master
            Changes to be committed:
            (use "git reset HEAD <file>..." to unstage)

                new file:   README
                modified:   CONTRIBUTING.md

            Changes not staged for commit:
            (use "git add <file>..." to update what will be committed)
            (use "git checkout -- <file>..." to discard changes in working directory)

                modified:   CONTRIBUTING.md

        Если вы изменили файл после выполнения git add, вам придётся снова выполнить git add, чтобы проиндексировать последнюю версию файла:

            $ git add CONTRIBUTING.md
            $ git status
            On branch master
            Changes to be committed:
            (use "git reset HEAD <file>..." to unstage)

                new file:   README
                modified:   CONTRIBUTING.md


->>    Сокращенный вывод статуса

        Git также имеет флаг вывода сокращенного статуса, так что вы можете увидеть изменения в более компактном виде. 
        Если вы выполните git status -s или git status --short вы получите гораздо более упрощенный вывод.

            $ git status -s
            M README - отредактированные файлы помечены
            MM Rakefile
            A  lib/git.rb - файлы добавленные в отслеживаемые помечены
            M  lib/simplegit.rb
            ?? LICENSE.txt -  неотслеживаемые файлы

        В выводе содержится два столбца - в левом указывается статус файла, а в правой модифицирован ли он после этого.

->>    Игнорирование файлов
        Зачастую, у вас имеется группа файлов, которые вы не только не хотите автоматически добавлять в репозиторий, 
        но и видеть в списках неотслеживаемых. К таким файлам обычно относятся автоматически генерируемые файлы (различные логи, результаты 
        сборки программ и т.п.). В таком случае, вы можете создать файл .gitignore. с перечислением шаблонов соответствующих таким файлам. 
        Вот пример файла .gitignore:

            $ cat .gitignore
            *.[oa] - Первая строка предписывает Git игнорировать любые файлы заканчивающиеся на ``.o`` или ``.a``
            *~ - предписывает игнорировать все файлы заканчивающиеся на тильду (~), которая используется во многих текстовых редакторах

        К шаблонам в файле .gitignore применяются следующие правила:
            - Пустые строки, а также строки, начинающиеся с #, игнорируются.
            - Можно использовать стандартные glob шаблоны.
            - Можно начать шаблон символом слэша (/) чтобы избежать рекурсии.
            - Можно заканчивать шаблон символом слэша (/) для указания каталога.
            - Можно инвертировать шаблон, использовав восклицательный знак (!) в качестве первого символа.


        Символ (*) соответствует 0 или более символам; 
        
        [abc] — любому символу из указанных в скобках (в данном примере a, b или c); 
        
        Знак вопроса (?) соответствует одному символу; 
        
        Квадратные скобки, в которые заключены символы, разделённые дефисом ([0-9]), соответствуют любому символу из интервала (в данном случае от 0 до 9). 
        
        Также можно использовать две звёздочки, чтобы указать на вложенные директории: a/**/z соответствует a/z, a/b/z, a/b/c/z, и так далее.



->>    Просмотр индексированных и неиндексированных изменений

        Если результат работы команды git status недостаточно информативен для вас — вам хочется знать, что конкретно поменялось, 
        а не только какие файлы были изменены — вы можете использовать команду git diff.
        
        Если git status отвечает на эти вопросы в самом общем виде, перечисляя имена файлов, git diff показывает вам непосредственно добавленные 
        и удалённые строки — собственно заплатку (patch).

        Если вы хотите посмотреть, что вы проиндексировали и что войдёт в следующий коммит, вы можете выполнить git diff --staged. Эта команда сравнивает 
        ваши индексированные изменения с последним коммитом:

            $ git diff --staged
            diff --git a/README b/README
            new file mode 100644
            index 0000000..03902a1
            --- /dev/null
            +++ b/README
            @@ -0,0 +1 @@
            +My Project

        Важно отметить, что git diff сама по себе не показывает все изменения сделанные с последнего коммита — только те, что ещё не проиндексированы. 
        Такое поведение может сбивать с толку, так как если вы проиндексируете все свои изменения, то git diff ничего не вернёт.

            - Используя git diff посмотреть непроиндексированные изменения
            - также уже проиндексированные, используя git diff --cached (--staged и --cached синонимы):


->>    Коммит изменений

         когда вы в последний раз выполняли git status, вы видели что всё проиндексировано, и вот, вы готовы к коммиту. 
         Простейший способ зафиксировать изменения — это набрать git commit:

            $ git commit

        Для ещё более подробного напоминания, что же именно вы поменяли, можете передать аргумент -v в команду git commit. Это приведёт к тому, 
        что в комментарий будет также помещена дельта/diff изменений, таким образом вы сможете точно увидеть все изменения которые вы совершили.
        
        Есть и другой способ — вы можете набрать свой комментарий к коммиту в командной строке вместе с командой commit указав его 
        после параметра -m, как в следующем примере:

            $ git commit -m "Story 182: Fix benchmarks for speed"
            [master 463dc4f] Story 182: Fix benchmarks for speed
            2 files changed, 2 insertions(+)
            create mode 100644 README

        Итак, вы создали свой первый коммит! Вы можете видеть, что коммит вывел вам немного информации о себе: 
           
            - На какую ветку вы выполнили коммит (master), 
            - Какая контрольная сумма SHA-1 у этого коммита (463dc4f), 
            - Сколько файлов было изменено, 
            - Также статистику по добавленным/удалённым строкам в этом коммите.

->>*   Игнорирование индексации

        Если у вас есть желание пропустить этап индексирования, Git предоставляет простой способ. Добавление параметра -a в команду 
        git commit заставляет Git автоматически индексировать каждый уже отслеживаемый на момент коммита файл, позволяя вам обойтись без git add:

            $ git commit -a -m 'added new benchmarks'
            [master 83e38c7] added new benchmarks
            1 file changed, 5 insertions(+), 0 deletions(-)

->>    Удаление файлов

        Для того чтобы удалить файл из Git, вам необходимо удалить его из отслеживаемых файлов а затем выполнить 
        коммит. Это позволяет сделать команда git rm, которая также удаляет файл из вашего рабочего каталога, так что вы в следующий раз не увидите 
        его как “неотслеживаемый”.

        Если вы просто удалите файл из своего рабочего каталога, он будет показан в секции ``Changes not staged for commit`` вывода команды git status:

            $ rm PROJECTS.md
            $ git status
            On branch master
            Your branch is up-to-date with 'origin/master'.
            Changes not staged for commit:
            (use "git add/rm <file>..." to update what will be committed)
            (use "git checkout -- <file>..." to discard changes in working directory)

                    deleted:    PROJECTS.md

            no changes added to commit (use "git add" and/or "git commit -a")



        Затем, если вы выполните команду git rm, удаление файла попадёт в индекс:

            $ git rm PROJECTS.md
            rm 'PROJECTS.md'
            $ git status
            On branch master
            Changes to be committed:
            (use "git reset HEAD <file>..." to unstage)

                deleted:    PROJECTS.md

         Если вы изменили файл и уже проиндексировали его, вы должны использовать принудительное удаление с помощью параметра -f.

         Мы можем захотеть оставить файл на жёстком диске, и убрать его из-под бдительного ока Git. Это особенно полезно, 
         если вы забыли добавить что-то в файл .gitignore и по ошибке проиндексировали

         Чтобы сделать это, используйте опцию --cached:

            $ git rm --cached README
        
         В команду git rm можно передавать файлы, каталоги или glob-шаблоны. Это означает, что вы можете вытворять что-то вроде:   

            $ git rm log/\*.log 

            или 
            
            $ git rm \*~  - эта команда удаляет все файлы, чьи имена заканчиваются на ~.

->>    Перемещение файлов

        Таким образом, наличие в Git команды mv выглядит несколько странным. Если вам хочется переименовать файл в Git, вы можете сделать что-то вроде:

            $ git mv file_from file_to

        и это отлично сработает. На самом деле, если вы выполните что-то вроде этого и посмотрите на статус, вы увидите, что Git считает, что произошло переименование файла:

            $ git mv README.md README
            $ git status
            On branch master
            Changes to be committed:
            (use "git reset HEAD <file>..." to unstage)

                renamed:    README.md -> README

        Однако, это эквивалентно выполнению следующих команд:

            $ mv README.md README
            $ git rm README.md
            $ git add README

        Git неявно определяет, что произошло переименование, поэтому неважно, переименуете вы файл так или используя команду mv. Единственное отличие состоит лишь в том, 
        что mv — это одна команда вместо трёх — это функция для удобства. Важнее другое — вы можете использовать любой удобный способ, чтобы переименовать файл, 
        и затем воспользоваться add/rm перед коммитом.


>   Операции отмены

        Отмена может потребоваться, если вы сделали коммит слишком рано, например, забыв добавить какие-то файлы или комментарий к коммиту. Если вы 
        хотите переделать коммит, можно запустить commit с параметром --amend (дополнить):

            $ git commit --amend
        
        если вы фиксируете изменения, и понимаете, что забыли проиндексировать изменения в файле, который хотели включить в коммит, можно сделать примерно так:

            $ git commit -m 'initial commit'
            $ git add forgotten_file
            $ git commit --amend

        В итоге получится единый коммит — второй коммит заменит результаты первого.

->>    Отмена подготовки файла  

        Например, скажем, вы изменили два файла, и хотите закоммитить их двумя раздельными изменениями, но случайно набрали git add *, и 
        добавили оба в индекс. Как отменить добавление одного из них? Команда git status напомнит вам:

            $ git add .
            $ git status
            On branch master
            Changes to be committed:
            (use "git reset HEAD <file>..." to unstage)

                renamed:    README.md -> README
                modified:   CONTRIBUTING.md

        Прямо под текстом “Changes to be committed” говорится: git reset HEAD <file>... для отмены добавления в индекс. 
        
        Давайте последуем этому совету, и отменим индексирование файла CONTRIBUTING.md:

           $ git reset HEAD CONTRIBUTING.md
            Unstaged changes after reset:
            M	CONTRIBUTING.md
            
            $ git status
            On branch master
            Changes to be committed:
            (use "git reset HEAD <file>..." to unstage)

                renamed:    README.md -> README

            Changes not staged for commit:
            (use "git add <file>..." to update what will be committed)
            (use "git checkout -- <file>..." to discard changes in working directory)

                modified:   CONTRIBUTING.md 

->>    Отмена изменения измененного файла

        Что делать, если вы поняли, что не хотите сохранять свои изменения файла CONTRIBUTING.md? Как можно просто «разызменить» 
        его — вернуть к тому виду, который был в последнем коммите (или к изначально склонированому, или еще как-то полученному в рабочий каталог)?

            Changes not staged for commit:
            (use "git add <file>..." to update what will be committed)
            (use "git checkout -- <file>..." to discard changes in working directory) <<<<----

                modified:   CONTRIBUTING.md

        Здесь довольно ясно указано, как отбросить сделанные изменения. Давайте так и сделаем:

            $ git checkout -- CONTRIBUTING.md
            $ git status
            On branch master
            Changes to be committed:
            (use "git reset HEAD <file>..." to unstage)

                renamed:    README.md -> README



>   Работа с удалёнными репозиториями

        Взаимодействие с другими пользователями предполагает управление удалёнными репозиториями, а также отправку и получение данных из них. 
        Управление репозиториями включает в себя как умение добавлять новые, так и умение удалять устаревшие репозитории, а также умение управлять 
        различными удалёнными ветками, объявлять их отслеживаемыми или нет и так далее. В данном разделе мы рассмотрим некоторые из этих навыков.



->>    Просмотр удалённых репозиториев

        Для того, чтобы просмотреть список настроенных удалённых репозиториев, вы можете запустить команду git remote. Она выведет названия доступных удалённых репозиториев. 
        
        Если вы клонировали репозиторий, то увидите как минимум ``origin`` — имя по умолчанию для исходного репозитория:

            $ git clone https://github.com/schacon/ticgit
            Cloning into 'ticgit'...
            remote: Reusing existing pack: 1857, done.
            remote: Total 1857 (delta 0), reused 0 (delta 0)
            Receiving objects: 100% (1857/1857), 374.35 KiB | 268.00 KiB/s, done.
            Resolving deltas: 100% (772/772), done.
            Checking connectivity... done.
            $ cd ticgit
            $ git remote
            origin
        
        Вы можете также указать ключ -v, чтобы просмотреть адреса для чтения и записи, привязанные к репозиторию:

            $ git remote -v
            origin	https://github.com/schacon/ticgit (fetch)
            origin	https://github.com/schacon/ticgit (push)

->>    Добавление удалённых репозиториев

         Для того, чтобы добавить удалённый репозиторий и присвоить ему имя (shortname), просто выполните команду git remote add [shortname] [url]:

            $ git remote
            origin

            $ git remote add pb https://github.com/paulboone/ticgit

            $ git remote -v
            origin	https://github.com/schacon/ticgit (fetch)
            origin	https://github.com/schacon/ticgit (push)
            pb	https://github.com/paulboone/ticgit (fetch)
            pb	https://github.com/paulboone/ticgit (push)

        Теперь вместо указания полного пути вы можете использовать pb. Например, если вы хотите получить изменения, которые есть у Пола, но нету у вас, 
        
        вы можете выполнить команду git fetch pb:

            $ git fetch pb
            remote: Counting objects: 43, done.
            remote: Compressing objects: 100% (36/36), done.
            remote: Total 43 (delta 10), reused 31 (delta 5)
            Unpacking objects: 100% (43/43), done.
            From https://github.com/paulboone/ticgit
            * [new branch]      master     -> pb/master
            * [new branch]      ticgit     -> pb/ticgit


->>    Получение изменений из удалённого репозитория - Fetch и Pull

        Для получения данных из удалённых проектов, следует выполнить:

            $ git fetch [remote-name]

        git fetch origin извлекает все наработки, отправленные (push) на этот сервер после того, как вы склонировали его.

        git fetch забирает данные в ваш локальный репозиторий, но не сливает их с какими-либо вашими наработками и не модифицирует то, над чем вы работаете в данный момент.


->>*   Отправка изменений в удаленный репозиторий (Push)

         git push [remote-name] [branch-name]. Чтобы отправить вашу ветку master на сервер origin (повторимся, что клонирование, как правило, настраивает оба этих имени автоматически), 
         
         вы можете выполнить следующую команду для отправки наработок на сервер:

            $ git push origin master

        Если вы и кто-то ещё одновременно клонируете - > затем он выполняет команду push, а затем команду push выполняете вы - > то ваш push точно будет отклонён. 
        
        Вам придётся сначала вытянуть (pull) их изменения и объединить с вашими. Только после этого вам будет позволено выполнить push.

->>    Просмотр удаленного репозитория

        Если хотите получить побольше информации об одном из удалённых репозиториев, вы можете использовать команду git remote show [remote-name]. 
        
        Выполнив эту команду с некоторым именем, например, origin, вы получите результат, аналогичный следующему:

            $ git remote show origin
            * remote origin
            Fetch URL: https://github.com/schacon/ticgit
            Push  URL: https://github.com/schacon/ticgit
            HEAD branch: master
            Remote branches:
                master                               tracked
                dev-branch                           tracked
            Local branch configured for 'git pull':
                master merges with remote master
            Local ref configured for 'git push':
                master pushes to master (up to date)

->>    Удаление и переименование удалённых репозиториев

        Для переименования ссылок в новых версиях Git’а можно вылолнить git remote rename, это изменит сокращённое имя, используемое для удалённого репозитория. 
        
        Например, если вы хотите переименовать pb в paul, вы можете это сделать при помощи git remote rename:

            $ git remote rename pb paul
            $ git remote
            origin
            paul

        Если по какой-то причине вы хотите удалить ссылку (вы сменили сервер или больше не используете определённое 
        зеркало, или, возможно, контрибьютор перестал быть активным), вы можете использовать git remote rm:

            $ git remote rm paul
            $ git remote
            origin



>   Работа с метками

        Как правило, эта функциональность используется для отметки моментов выпуска версий (v1.0, и т.п.). В этом разделе вы узнаете, как посмотреть имеющиеся метки (tag), 
        как создать новые. А также вы узнаете, что из себя представляют разные типы меток.

->>    Просмотр меток

        Просмотр имеющихся меток (tag) в Git’е делается просто. Достаточно набрать git tag:

            $ git tag
            v0.1
            v1.3

->>    Создание меток

        Git использует два основных типа меток: легковесные и аннотированные.

            - Легковесная метка — это что-то весьма похожее на ветку, которая не меняется — это просто указатель на определённый коммит.
            
            - Аннотированные метки хранятся в базе данных Git’а как полноценные объекты. Они имеют контрольную сумму, содержат имя поставившего метку, 
                e-mail и дату, имеют комментарий и могут быть подписаны и проверены с помощью GNU Privacy Guard (GPG).

->>    Аннотированные метки

        Создание аннотированной метки в Git’е выполняется легко. Самый простой способ это указать -a при выполнении команды tag:

            $ git tag -a v1.4 -m 'my version 1.4'
            $ git tag
            v0.1
            v1.3
            v1.4
        
        Опция -m задаёт сообщение метки, которое будет храниться вместе с меткой. Если не указать сообщение для аннотированной метки, Git запустит редактор, 
        чтоб вы смогли его ввести.

        Вы можете посмотреть данные метки вместе с коммитом, который был помечен, с помощью команды git show:

            $ git show v1.4
            tag v1.4
            Tagger: Ben Straub <ben@straub.cc>
            Date:   Sat May 3 20:19:12 2014 -0700

            my version 1.4

            commit ca82a6dff817ec66f44342007202690a93763949
            Author: Scott Chacon <schacon@gee-mail.com>
            Date:   Mon Mar 17 21:52:11 2008 -0700

                changed the version number

->>    Легковесные метки

        Легковесная метка — это ещё один способ отметки коммитов. В сущности, это контрольная сумма коммита, сохранённая в 
        файл — больше никакой информации не хранится. Для создания легковесной метки не передавайте опций -a, -s и -m:

            $ git tag v1.4-lw
            $ git tag
            v0.1
            v1.3
            v1.4
            v1.4-lw
            v1.5

->>    Выставление меток позже

        Вы можете добавить метку и позже. Для отметки коммита укажите его контрольную сумму (или её часть) в конце команды:

            $ git tag -a v1.2 9fceb02


->>    Обмен метками

        Это делается так же, как и добавление в репозиторий для совместного использования удалённых веток — нужно выполнить git push origin [имя метки].

            $ git push origin v1.5
            Counting objects: 14, done.
            Delta compression using up to 8 threads.
            Compressing objects: 100% (12/12), done.
            Writing objects: 100% (14/14), 2.05 KiB | 0 bytes/s, done.
            Total 14 (delta 3), reused 0 (delta 0)
            To git@github.com:schacon/simplegit.git
            * [new tag]         v1.5 -> v1.5

        Если у вас есть много меток, которые хотелось бы отправить все за один раз, можно использовать опцию --tags для команды git push. 

        В таком случае все ваши метки отправятся на удалённый сервер (если только их уже там нет).


>   Псевдонимы в Git

        Если вы не хотите печатать каждую команду для Git’а целиком, вы легко можете настроить псевдонимы (alias) 
        
        для любой команды с помощью git config. Вот несколько примеров псевдонимов, которые вы, возможно, захотите задать:

            $ git config --global alias.co checkout
            $ git config --global alias.br branch
            $ git config --global alias.ci commit
            $ git config --global alias.st status

        Можно сказать, что Git просто заменяет эти команды на созданные вами псевдонимы (alias). Однако, возможно, вы захотите выполнить внешнюю команду, 
        а не подкоманду Git’а. В этом случае, следует начать команду с символа !. Это полезно, если вы пишете свои утилиты для работы с Git-репозиторием. 
        
        Продемонстрируем этот случай на примере создания псевдонима git visual для запуска gitk:

            $ git config --global alias.visual "!gitk"